# Лабораторная работа 1
**Руководство пользователя Описание кнопок и функций**

*Файл:* 
1. Создать: Создает новый документ. Если текущий документ содержит несохраненные изменения, программа предложит сохранить их. 
2. Открыть: Открывает существующий текстовый файл. Вы можете выбрать файл через диалоговое окно. 
3. Сохранить: Сохраняет текущий документ. Если файл уже был сохранен ранее, изменения будут записаны в тот же файл. Если файл новый, откроется диалоговое окно для выбора места сохранения. 
4. Сохранить как: Сохраняет текущий документ под новым именем или в новом месте. 
5. Выход: Закрывает программу. Если есть несохраненные изменения, программа предложит сохранить их перед выходом.

*Правка:*
1. Отменить: Отменяет последнее действие. 
2. Повторить: Повторяет последнее отмененное действие. 
3. Вырезать: Вырезает выделенный текст и помещает его в буфер обмена. 
4. Копировать: Копирует выделенный текст в буфер обмена. 
5. Вставить: Вставляет текст из буфера обмена в текущую позицию курсора. 
6. Удалить: Удаляет выделенный текст. 
7. Выделить все: Выделяет весь текст в документе.

*Текст:*
1. Постановка задачи: Отображает описание задачи, для которой создан текстовый редактор.
2. Грамматика: Показывает грамматические правила, используемые в языковом процессоре. 
3. Классификация грамматики: Описывает тип грамматики, используемой в программе. 
4. Метод анализа: Описывает метод, используемый для анализа текста. 
5. Диагностика и нейтрализация ошибок: Описывает, как программа обнаруживает и исправляет ошибки в тексте. 
6. Тестовый пример: Предоставляет пример текста для тестирования функциональности программы. 
7. Список литературы: Содержит список использованной литературы. 
8. Исходный код программы: Показывает исходный код программы (если доступно).

*Пуск:*
1. Запуск анализатора: Запускает языковой процессор для анализа текста. Результаты анализа отображаются в области результатов.
Справка:
2. Вызов справки: Открывает это руководство пользователя. 
3. О программе: Показывает информацию о программе, включая версию и автора.


# Лабораторная работа 2
Персональный вариант: Лямбда-выражения языка Java

## В соответствии с заданием второй лабораторной работы необходимо:
- Спроектировать диаграмму состояний сканера.
- Разработать лексический анализатор, позволяющий выделить в тексте лексемы, иные символы считать недопустимыми.
- Встроить сканер в ранее разработанный интерфейс текстового редактора. Учесть, что текст для разбора может состоять из множества строк.

Входные данные - строка (текст программного кода).
Выходные данные - последовательность условных кодов, описывающих структуру разбираемого текста с указанием места положения и типа ("число", "идентификатор", "знак", "недопустимый символ" и т.д.). 
Окно вывода результатов можно реализовать в виде таблицы (элемент управления DataGridView). Столбцы таблицы представляют собой условный код, тип лексемы, лексема и ее местоположение.
## Примеры допустимых строк:
- operation = (x,y,z)->x+(y*z);

# Лабораторная работа 3

1) <LAMBDA_EXPRESSION> -> <PARAMETERS> "->" <EXPRESSION>
2) <PARAMETERS> -> "(" <IDENTIFIER_LIST> ")"
3) <IDENTIFIER_LIST> -> <IDENTIFIER> <IDENTIFIER_TAIL>
4) <IDENTIFIER_TAIL> -> "," <IDENTIFIER> <IDENTIFIER_TAIL>
5) <IDENTIFIER_TAIL> -> ε
6) <EXPRESSION> -> <TERM> <EXPRESSION_TAIL>
7) <EXPRESSION_TAIL> -> "+" <TERM> <EXPRESSION_TAIL>
8) <EXPRESSION_TAIL> -> "-" <TERM> <EXPRESSION_TAIL>
9) <EXPRESSION_TAIL> -> ε
10) <TERM> -> <FACTOR> <TERM_TAIL>
11) <TERM_TAIL> -> "*" <FACTOR> <TERM_TAIL>
12) <TERM_TAIL> -> "/" <FACTOR> <TERM_TAIL>
13) <TERM_TAIL> -> ε
14) <FACTOR> -> <IDENTIFIER>
15) <FACTOR> -> "(" <EXPRESSION> ")"
16) <IDENTIFIER> -> <LETTER> <IDENTIFIER_TAIL>
17) <IDENTIFIER_TAIL> -> <LETTER> <IDENTIFIER_TAIL>
18) <IDENTIFIER_TAIL> -> "_" <IDENTIFIER_TAIL>
19) <IDENTIFIER_TAIL> -> ε
<LETTER> -> "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
Следуя введенному формальному определению грамматики, представим G[‹LambdaExpression›] ее составляющими:
•	Z = ‹ LAMBDA_EXPRESSION›;
•	VT = {a, b, ..., z, A, B, ..., Z, _, =, +, -, *, /, (, ), ,, ->};
•	VN = {<LAMBDA_EXPRESSION>, <PARAMETERS>, <IDENTIFIER_LIST>, <IDENTIFIER_TAIL>, <EXPRESSION>, <TERM>, <TERM_TAIL>, <FACTOR>, <IDENTIFIER>, <IDENTIFIER_TAIL>, <LETTER>}.


<img width="441" alt="image" src="https://github.com/user-attachments/assets/719fdde5-186a-409a-8628-9e130408dfc6" />


# Лабораторная работа 4

1) <LAMBDA_EXPRESSION> -> <PARAMETERS> "->" <EXPRESSION>
2) <PARAMETERS> -> "(" <IDENTIFIER_LIST> ")"
3) <IDENTIFIER_LIST> -> <IDENTIFIER> <IDENTIFIER_TAIL>
4) <IDENTIFIER_TAIL> -> "," <IDENTIFIER> <IDENTIFIER_TAIL>
5) <IDENTIFIER_TAIL> -> ε
6) <EXPRESSION> -> <TERM> <EXPRESSION_TAIL>
7) <EXPRESSION_TAIL> -> "+" <TERM> <EXPRESSION_TAIL>
8) <EXPRESSION_TAIL> -> "-" <TERM> <EXPRESSION_TAIL>
9) <EXPRESSION_TAIL> -> ε
10) <TERM> -> <FACTOR> <TERM_TAIL>
11) <TERM_TAIL> -> "*" <FACTOR> <TERM_TAIL>
12) <TERM_TAIL> -> "/" <FACTOR> <TERM_TAIL>
13) <TERM_TAIL> -> ε
14) <FACTOR> -> <IDENTIFIER>
15) <FACTOR> -> "(" <EXPRESSION> ")"
16) <IDENTIFIER> -> <LETTER> <IDENTIFIER_TAIL>
17) <IDENTIFIER_TAIL> -> <LETTER> <IDENTIFIER_TAIL>
18) <IDENTIFIER_TAIL> -> "_" <IDENTIFIER_TAIL>
19) <IDENTIFIER_TAIL> -> ε
<LETTER> -> "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
Следуя введенному формальному определению грамматики, представим G[‹LambdaExpression›] ее составляющими:
•	Z = ‹ LAMBDA_EXPRESSION›;
•	VT = {a, b, ..., z, A, B, ..., Z, _, =, +, -, *, /, (, ), ,, ->};
•	VN = {<LAMBDA_EXPRESSION>, <PARAMETERS>, <IDENTIFIER_LIST>, <IDENTIFIER_TAIL>, <EXPRESSION>, <TERM>, <TERM_TAIL>, <FACTOR>, <IDENTIFIER>, <IDENTIFIER_TAIL>, <LETTER>}.


<img width="441" alt="image" src="https://github.com/user-attachments/assets/719fdde5-186a-409a-8628-9e130408dfc6" />



# Лабораторная работа 6

Построить РВ, описывающее HTML-комментарии.

<img width="300" alt="image" src="https://github.com/user-attachments/assets/096ef0dc-67a5-4946-99b7-e627d3a0bb65" />




<img width="1500" alt="image" src="https://github.com/user-attachments/assets/15285d2f-6898-46f8-9dd1-e6927d15e382" />



<img width="533" alt="image" src="https://github.com/user-attachments/assets/debafeb6-8313-4218-9f3f-1a61ed47829e" />

Построить РВ для того, чтобы найти все годы между 2010 и
2024.

@"\b(20(1[0-9]|2[0-4]))\b"

Разбор:

\b – граница слова (чтобы не захватывать части чисел, например, 52021).
20 – первые две цифры всех годов (2000–2099).
(1[0-9]|2[0-4]) – две возможные группы:
1[0-9] – от 10 до 19 (годы 2010–2019).
2[0-4] – от 20 до 24 (годы 2020–2024).
\b – закрывающая граница слова.


<img width="533" alt="image" src="https://github.com/user-attachments/assets/c9772be2-991c-4070-b8f7-a13b67f27bcf" />



Построить РВ, описывающее путь к файлу в Windows.

@"^(?:[a-zA-Z]:\\|\\\\[^\\\/:*?""<>|\r\n]+\\[^\\\/:*?""<>|\r\n]+\\|\.{0,2}\\)?(?:[^\\\/:*?""<>|\r\n]+\\)*[^\\\/:*?""<>|\r\n]*$"

Разбор выражения:

Начало пути (^)
(?: ... )? – необязательная группа (относительные пути могут начинаться без диска/сервера).
Абсолютный путь (диск или UNC):
[a-zA-Z]:\\ – буква диска (C:\, D:\ и т. д.).
\\\\[^\\\/:*?"<>|\r\n]+\\[^\\\/:*?"<>|\r\n]+\\ – UNC-путь (\\Server\Share\).
Относительный путь:
\.{0,2}\\ – текущая (.\) или родительская (..\) директория.
Папки и файл:
(?:[^\\\/:*?"<>|\r\n]+\\)* – любое количество папок (без запрещённых символов).
[^\\\/:*?"<>|\r\n]* – имя файла (может быть пустым для папок).
Конец строки ($) – гарантирует, что путь не содержит лишних символов.


<img width="532" alt="image" src="https://github.com/user-attachments/assets/8bbe81ce-6e63-4343-9a9c-86528dbbb6be" />



<img width="252" alt="image" src="https://github.com/user-attachments/assets/cb1383d8-8541-424f-a2ce-b6b898beb503" />


# Лаба 8 Реализация метода рекурсивного спуска для синтаксического анализа.
## Грамматика
Вариант 17 
Для грамматики G[Program] разработать и реализовать алгоритм 
анализа на основе метода рекурсивного спуска. 
G[Program]: 
1. 
Program -> ε | Instr Program 
2. 
Program ']' 
Instr -> '+' | '-' | '*' | '/' | '_' | '=' | '>' | '&' | '|' | '~' | '$' | '%' | '\' | '@' | '[' 
Примечание: данными продукциями описывается эзотерический 
язык программирования FALSE.
## Язык
Язык L(G[Program]), порождаемый грамматикой G[Program]:
L(G[Program]) =  {+, -, *, /, _, =, >, &, |, ~, $, %, , @, [, ]}
## Классификация грамматики
Согласно классификации Хомского, грамматика G[Выражение] является контекстно-свободной, так как имеет вид:
A → α, где A∈VN, α∈V*.
## Схема вызова

![image](https://github.com/user-attachments/assets/4a71e75a-d71f-4c26-91d7-a6ea64716e20)



## Тестовые примеры

![image](https://github.com/user-attachments/assets/9e89dd8d-8e78-47b6-b9de-732a8e597c5b)


## Примеры допустимых строк
+-*@ (последовательность операций)
[++--] (простой цикл)
+[*@][-] (несколько блоков кода)
[[+]-] (вложенные циклы)

